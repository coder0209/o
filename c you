1.FCFS:
#include <stdio.h>

struct process {
    int at;     // Arrival Time
    int bt;     // Burst Time
    int id;     // Process ID
    int ct;     // Completion Time
    int tat;    // Turnaround Time
    int wt;     // Waiting Time
};

void fcfs(struct process p[], int n) {
    int i, cur = 0;
    int ttat = 0, twt = 0;
    double avgtat, avgtwt;
    
    // Sort processes by arrival time
    for (i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (p[i].at > p[j].at) {
                struct process temp = p[i];
                p[i] = p[j];
                p[j] = temp;
            }
        }
    }
    
    // FCFS scheduling calculation
    for (i = 0; i < n; i++) {
        if (cur < p[i].at) {
            cur = p[i].at;  // Update current time to the process's arrival time if idle
        }
        p[i].ct = cur + p[i].bt;  // Calculate completion time
        cur = p[i].ct;  // Update current time to completion time of this process
        p[i].tat = p[i].ct - p[i].at;  // Turnaround time
        p[i].wt = p[i].tat - p[i].bt;  // Waiting time
        ttat += p[i].tat;  // Accumulate total turnaround time
        twt += p[i].wt;  // Accumulate total waiting time
    }

    // Print process details and results
    printf("\n \t\t pid \t bt \t at \t ct \t tat \t wt \n");
    for (i = 0; i < n; i++) {
        printf("\n \t\t %d \t\t %d \t\t %d \t\t %d \t\t %d \t\t %d \n", 
               p[i].id, p[i].bt, p[i].at, p[i].ct, p[i].tat, p[i].wt);
    }

    avgtat = (double)(ttat) / n;
    avgtwt = (double)(twt) / n;
    printf("\nAverage Turnaround Time (TAT): %.2lf", avgtat);
    printf("\nAverage Waiting Time (WT): %.2lf\n", avgtwt);
}

int main() {
    int n, i;
    printf("\nEnter number of processes: ");
    scanf("%d", &n);
    struct process p[n];
    for (i = 0; i < n; i++) {
        printf("Enter the arrival time of process %d: ", i + 1);
        scanf("%d", &p[i].at);
        printf("Enter the burst time of process %d: ", i + 1);
        scanf("%d", &p[i].bt);
        p[i].id = i + 1;  // Assign process ID
    }
    fcfs(p, n);
    return 0;
}
------------------------------------------------------------------------------------------------
2.Round Robin:
#include <stdio.h>

struct process {
    int pid;      // Process ID
    int at;       // Arrival Time
    int bt;       // Burst Time
    int ct;       // Completion Time
    int wt;       // Waiting Time
    int tat;      // Turnaround Time
    int rem_bt;   // Remaining Burst Time
};

int main() {
    int n, time_quantum;

    // Input the number of processes
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct process list[n];

    // Input the arrival time and burst time for each process
    for (int i = 0; i < n; i++) {
        printf("Enter the arrival time and burst time for process %d: ", i + 1);
        scanf("%d%d", &list[i].at, &list[i].bt);
        list[i].pid = i + 1;
        list[i].rem_bt = list[i].bt;
        list[i].wt = 0;
        list[i].tat = 0;
        list[i].ct = 0;
    }

    // Input the time quantum
    printf("Enter the time quantum: ");
    scanf("%d", &time_quantum);

    int current_time = 0; // Track the current time
    int processes_remaining = n;

    // Round Robin scheduling algorithm
    while (processes_remaining > 0) {
        int done_in_this_cycle = 0;

        for (int i = 0; i < n; i++) {
            // Process only if it has arrived and has remaining burst time
            if (list[i].rem_bt > 0 && list[i].at <= current_time) {
                done_in_this_cycle = 1;
            int exec_time;
if (list[i].rem_bt > time_quantum) {
    exec_time = time_quantum;
} else {
    exec_time = list[i].rem_bt;
}

                // Update the time and remaining burst time
                current_time += exec_time;
                list[i].rem_bt -= exec_time;

                // If process is completed
                if (list[i].rem_bt == 0) {
                    list[i].ct = current_time;  // Set completion time
                    list[i].tat = list[i].ct - list[i].at; // Turnaround Time
                    list[i].wt = list[i].tat - list[i].bt; // Waiting Time
                    processes_remaining--;
                }
            }
        }

        // If no process was executed in this cycle, move time forward
        if (!done_in_this_cycle) {
            current_time++;
        }
    }

    float total_wt = 0, total_tat = 0;

    // Output the results
    printf("\nProcess\tArrival Time\tBurst Time\tCompletion Time\tWaiting Time\tTurnaround Time\n");
    for (int i = 0; i < n; i++) {
        total_wt += list[i].wt;
        total_tat += list[i].tat;
        printf("%d\t%d\t\t%d\t\t%d\t\t%d\t\t%d\n", list[i].pid, list[i].at, list[i].bt, list[i].ct, list[i].wt, list[i].tat);
    }

    // Calculate and print the average waiting time and turnaround time
    printf("\nAverage Waiting Time = %.2f", total_wt / n);
    printf("\nAverage Turnaround Time = %.2f\n", total_tat / n);

    return 0;
}
-----------------------------------------------------------------------------------------------
3.SJF:
#include<stdio.h>
struct process
{
int at;
int bt;
int id;
int ct;
int tat;
int wt;
int status;
};
int dispatcher(struct process p[],int n,int cur)
{
int i,j,max=1000;
for(i=0;i<n;i++)
{
if(p[i].status!=1&&p[i].at<=cur)
{
if(p[i].bt<=max)
{
max=p[i].bt;
j=i;
}

}
}
return j;
}
void sort(struct process p[],int n)
{
int i,j;
int cur=0;
int ttat=0;
int twt=0;
i=0;
while(i<n)
{
j=dispatcher(p,n,cur);
p[j].ct=cur+p[j].bt;
cur=p[j].ct;
p[j].tat=p[j].ct-p[j].at;
ttat+=p[j].tat;
p[j].wt=p[j].tat-p[j].bt;
twt+=p[j].wt;
p[j].status=1;
i++;

}
printf(" \n \t\t pid \t bt \t at \t ct \t tat \t wt \n");
for(i=0;i<n;i++)
{
printf("\n \t\t %d \t\t %d \t\t %d \t\t %d \t\t %d \t \t%d \n",p[i].id,p[i].bt,p[i].at,p[i].ct,p[i].tat,p[i].wt);
}
double avgtat=(double)(ttat)/n;
double avgtwt=(double)(twt)/n;
printf("\n avgtat: %.2lf",avgtat);
printf("\n avgtwt: %.2lf",avgtwt);

}
int main()
{
int n,i;
printf("\n enter no of processes: ");
scanf("%d",&n);
struct process p[n];
for(i=0;i<n;i++)
{
printf("enter the arraival time of process %d :",i+1);
scanf("%d",&p[i].at);
printf("enter the burst time of process %d :",i+1);
scanf("%d",&p[i].bt);
p[i].id=i+1;
p[i].status=0;
}
sort(p,n);
return 0;
}
-------------------------------------------------------------------------------------------------      
4.SRTF:
#include <stdio.h>

struct process {
    int at;     // Arrival Time
    int bt;     // Burst Time
    int rt;     // Remaining Time
    int id;     // Process ID
    int ct;     // Completion Time
    int tat;    // Turnaround Time
    int wt;     // Waiting Time
    int status; // Status (0 = not complete, 1 = complete)
};

void srtf(struct process p[], int n) {
    int completed = 0, cur = 0, min_rt = 1000;
    int i, shortest = -1, finish_time;
    int ttat = 0, twt = 0;
    double avgtat, avgtwt;
    
    while (completed != n) {
        for (i = 0; i < n; i++) {
            if (p[i].at <= cur && p[i].status == 0 && p[i].rt < min_rt) {
                min_rt = p[i].rt;
                shortest = i;
            }
        }

        if (shortest == -1) {
            cur++;
            continue;
        }

        p[shortest].rt--;
        min_rt = p[shortest].rt;

        if (min_rt == 0) {
            min_rt = 1000;
            completed++;
            finish_time = cur + 1;
            p[shortest].ct = finish_time;
            p[shortest].tat = p[shortest].ct - p[shortest].at;
            p[shortest].wt = p[shortest].tat - p[shortest].bt;
            p[shortest].status = 1;
            ttat += p[shortest].tat;
            twt += p[shortest].wt;
        }

        cur++;
    }

    printf("\n \t\t pid \t bt \t at \t ct \t tat \t wt \n");
    for (i = 0; i < n; i++) {
        printf("\n \t\t %d \t\t %d \t\t %d \t\t %d \t\t %d \t\t %d \n", 
               p[i].id, p[i].bt, p[i].at, p[i].ct, p[i].tat, p[i].wt);
    }

    avgtat = (double)(ttat) / n;
    avgtwt = (double)(twt) / n;
    printf("\nAverage Turnaround Time (TAT): %.2lf", avgtat);
    printf("\nAverage Waiting Time (WT): %.2lf\n", avgtwt);
}

int main() {
    int n, i;
    printf("\nEnter number of processes: ");
    scanf("%d", &n);
    struct process p[n];
    for (i = 0; i < n; i++) {
        printf("Enter the arrival time of process %d: ", i + 1);
        scanf("%d", &p[i].at);
        printf("Enter the burst time of process %d: ", i + 1);
        scanf("%d", &p[i].bt);
        p[i].id = i + 1;
        p[i].rt = p[i].bt;  // Initially, remaining time is equal to burst time
        p[i].status = 0;
    }
    srtf(p, n);
    return 0;
}
