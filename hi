#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<pthread.h>

void *calprime(void *inp)
{
    int *input=(int*)inp;
    int flag=0;
    
    for (int i=2;i<=*input/2;i++)
    {
        if(input%i == 0)
        {
            flag++;
            break;
        }
    }
    if(flag==0)
    {
        printf("%d is a prime number",*input);
    }
    else{printf("%d is not a primenumber",*input);}

}
void *armstrong(void *inp)
{
    int *input=(int *)inp;
    int temp=*input;
    int n=0;
    float res=0.0;
    for(temp=*input;temp!=0;n++)
    {
    temp/=10;
      }
    for(temp=*input;temp!=0;temp/=10)
    {
        int remainder=temp%10;
        int tempres=1;
        for(int j=0;j<n;j++)
        {
            tempres*=remainder;
        }
        res+=tempres;
    }
    if ((int)res ==*input)
    {
        printf("%d is an armstrong",*input);
    }
    else{printf("%d is not an armstrong",*input);}
}

void factorial(void *inp)
{
    int input=(int *)inp;
    long int res=1;
    for(int i=1;i<=*input;i++)
    {
        res*=i;
    }
    printf("Factorial of %d is %ld",*input,res);
}

int main()
{
    pthread_t threads[6];
    int n;
    while(1>0)
    {
        printf("Enter your value: \n");

        scanf("%d",&n);
        pthread_create(&threads[0],NULL,calprime,(void *)&n);
        pthread_create(&threads[1],NULL,factorial,(void *)&n);
        pthread_create(&threads[2],NULL,armstrong,(void *)&n);

        pthread_join(threads[0],NULL);
        pthread_join(threads[1],NULL);
        pthread_join(threads[2],NULL);
    }
    exit(0);
}
--------------------------------------------------------------------------------------------------------------------------------------------------
//producer
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/ipc.h>

#define SIZE 5 // Buffer size

struct shared {
    sem_t mutex;       // Semaphore for mutual exclusion
    sem_t empcnt;      // Semaphore for empty slots
    sem_t fullcnt;     // Semaphore for full slots
    int array[SIZE];   // Shared buffer
    int front, rear;   // Indices for the buffer
};

// Function to produce an item
int pr_it() {
    static int a = 1;
    return a++;
}

// Function to insert an item into the buffer
void ins_it(struct shared *s, int item) {
    s->rear = (s->rear + 1) % SIZE;
    s->array[s->rear] = item;
}

// Producer thread function
void *producer(void *arg) {
    struct shared *s = (struct shared *)arg;
    int item;
    
    while (1) {
        item = pr_it();  // Generate an item
        sem_wait(&s->empcnt);  // Wait for an empty slot
        sem_wait(&s->mutex);    // Enter critical section

        printf("\nProducer inserting item %d\n", item);
        ins_it(s, item);  // Insert item into buffer

        sem_post(&s->mutex);    // Exit critical section
        sem_post(&s->fullcnt);   // Signal that a new item is produced

        sleep(1);  // Simulate time taken to produce an item
    }
}

int main() {
    int shmid;
    struct shared *s;

    // Create shared memory
    shmid = shmget(1234, sizeof(struct shared), 0666 | IPC_CREAT);
    s = (struct shared *)shmat(shmid, NULL, 0);

    // Initialize semaphores
    sem_init(&s->mutex, 1, 1);
    sem_init(&s->empcnt, 1, SIZE); // Initially all slots are empty
    sem_init(&s->fullcnt, 1, 0);   // No items are produced

    s->front = s->rear = -1; // Initialize indices

    pthread_t pid;
    pthread_create(&pid, NULL, producer, (void *)s);
    pthread_join(pid, NULL);

    // Detach and delete shared memory
    shmdt(s);
    shmctl(shmid, IPC_RMID, NULL);
    return 0;
}
//consumer
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/shm.h>
#include <sys/ipc.h>

#define SIZE 5 // Buffer size

struct shared {
    sem_t mutex;       // Semaphore for mutual exclusion
    sem_t empcnt;      // Semaphore for empty slots
    sem_t fullcnt;     // Semaphore for full slots
    int array[SIZE];   // Shared buffer
    int front, rear;   // Indices for the buffer
};

// Function to remove an item from the buffer
int remove_item(struct shared *s) {
    s->front = (s->front + 1) % SIZE;
    return s->array[s->front];
}

// Consumer thread function
void *consumer(void *arg) {
    struct shared *s = (struct shared *)arg;
    int item;
    
    while (1) {
        sleep(2); // Simulate time taken to consume an item
        sem_wait(&s->fullcnt);  // Wait for a full slot
        sem_wait(&s->mutex);     // Enter critical section

        item = remove_item(s);   // Remove item from buffer
        printf("Consumer consumed item %d\n", item);

        sem_post(&s->mutex);      // Exit critical section
        sem_post(&s->empcnt);     // Signal that a slot is now empty
    }
}

int main() {
    int shmid;
    struct shared *s;

    // Access shared memory
    shmid = shmget(1234, sizeof(struct shared), 0666);
    s = (struct shared *)shmat(shmid, NULL, 0);

    pthread_t cid;
    pthread_create(&cid, NULL, consumer, (void *)s);
    pthread_join(cid, NULL);

    // Detach shared memory
    shmdt(s);
    return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------
//dining philo
#include<stdio.h>
#include<pthread.h>
#include<semaphore.h>
#include<unistd.h>
#define n 5
#define left (i+n-1)%n
#define right (i+1)%n
#define think 0
#define hung 1
#define eat 2

int i=1,j;
int state[n];
sem_t mutex;
sem_t s[n];
void test(int);
void put_fork(int);
void take_fork(int);
void *philosopher(void *i)
{
int *p=(int *)i;
while(1)
{
printf("\n %d philos is think",*p);
sleep(1);
take_fork(*p);
printf("\n %d philos is eating",*p);
sleep(1);
put_fork(*p);


}
}
void take_fork(int i)
{
sem_wait(&mutex);
state[i]=hung;
printf("\n %d philos is hungry",i);
test(i);
sem_post(&mutex);
sem_wait(&s[i]);
}
void put_fork(int i)
{
sem_wait(&mutex);
state[i]=think;
test(left);
test(right);
sem_post(&mutex);
}
void test(int i)
{
if(state[i]==hung&&state[left]!=eat&&state[right]!=eat)
{
state[i]=eat;
sem_post(&s[i]);
}
}
int main()
{
pthread_t p1,p2,p3,p4,p5;
int p[5]={0,1,2,3,4};
sem_init(&mutex,0,1);
pthread_create(&p1,NULL,philosopher,(void*)&p[0]);
pthread_create(&p2,NULL,philosopher,(void*)&p[1]);
pthread_create(&p3,NULL,philosopher,(void*)&p[2]);
pthread_create(&p4,NULL,philosopher,(void*)&p[3]);
pthread_create(&p5,NULL,philosopher,(void*)&p[4]);
pthread_join(p1,NULL);
pthread_join(p2,NULL);
pthread_join(p3,NULL);
pthread_join(p4,NULL);
pthread_join(p5,NULL);
return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------
//deadlock
#include <stdio.h>
int main()
{
int n, m, i, j, k, avail[10],alloc[10][10],max[10][10],need[10][10];
printf("Enter number of processes: ");
scanf("%d",&n);
printf("Enter number of resources: ");
scanf("%d",&m);
printf("Enter the number of available resources:\n");
for(i=0;i<m;i++)
{
printf("Resource%d: ",i);
scanf("%d",&avail[i]);
}
printf("\nEnter maximum resource demand of each process:\n");
for(i=0;i<n;i++)
{
printf("Process %d :\n",i);
for(j=0;j<m;j++)
{
scanf("%d",&max[i][j]);
}
}
printf("\nEnter already allocated resources of each process:\n");
for(i=0;i<n;i++)
{
printf("Process %d:",i);
for(j=0;j<m;j++)
{
scanf("%d",&alloc[i][j]);
}
}
int f[n], ans[n], ind = 0;
for (k = 0; k < n; k++) {
f[k] = 0; // to be used to trace which proceeses have completed
}
//Calculate the current need of all the processes
for (i = 0; i < n; i++) {
for (j = 0; j < m; j++)
need[i][j] = max[i][j] - alloc[i][j];
}
int y = 0;
for (k = 0; k < n; k++) {
for (i = 0; i < n; i++) {
if (f[i] == 0) {
int flag = 0;
for (j = 0; j < m; j++) {
if (need[i][j] > avail[j])//Need exceeds availability

{
flag = 1; // ith process can not be completed
break;
}
}
if (flag == 0)
{
ans[ind++] = i;// Constructing safe sequence
for (y = 0; y < m; y++)
avail[y] += alloc[i][y]; // Reclaim the resource from completed process
f[i] = 1; // Update that ith process is completed
}
}
}
}
int flag = 1;
for(int i=0;i<n;i++)
{
if(f[i]==0) // If a process could not be completed
{
flag=0;
printf("The following system is not safe");
break;
}
}
if(flag==1) //All the processes can be completed
{
printf("Following is the SAFE Sequence\n");
for (i = 0; i < n - 1; i++)
printf(" P%d ->", ans[i]);
printf(" P%d", ans[n - 1]);
}
return (0);
}
--------------------------------------------------------------------------------------------------------------------------------------------------
//peterson
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
#include <sys/wait.h> 
#include <stdbool.h> 
#define MAX_TICKETS 10 
#define N 5  // Number of clients 
// Shared data 
int tickets = MAX_TICKETS; 
bool interested[N] = {false}; 
int turn[N] = {0}; 
// Peterson's solution for n processes 
void enter_critical_section(int process_id) { 
for (int i = 0; i < N; i++) { 
if (i != process_id) { 
interested[process_id] = true; 
turn[process_id] = i; 
while (interested[i] && turn[i] == process_id) { 
// Busy wait 
} 
} 
} 
} 
void leave_critical_section(int process_id) { 
interested[process_id] = false; 
} 
// Booking server simulation 
void book_ticket(int client_id) { 
enter_critical_section(client_id); 
if (tickets > 0) { 
printf("Client %d booking a ticket. Tickets remaining: %d\n", client_id, tickets - 1); 
tickets--; 
} else { 
printf("Client %d could not book a ticket. No tickets remaining.\n", client_id); 
} 
leave_critical_section(client_id); 
} 
int main() { 
pid_t pids[N]; 
for (int i = 0; i < N; i++) { 
if ((pids[i] = fork()) == 0) { 
// Child process (client) 
for (int j = 0; j < 3; j++) {  // Each client tries to book 3 times 
book_ticket(i); 
sleep(rand() % 3);  // Simulate some delay between booking attempts 
} 
exit(EXIT_SUCCESS); 
} else if (pids[i] < 0) { 
perror("fork"); 
exit(EXIT_FAILURE); 
} 
} 
// Parent process 
for (int i = 0; i < N; i++) { 
wait(NULL);  // Wait for all child processes to finish 
} 
return 0; 
}
--------------------------------------------------------------------------------------------------------------------------------------------------
//reader,writer
#include<stdio.h>
#include<semaphore.h>
#include<pthread.h>

sem_t wrt;
pthread_mutex_t mutex;
int cnt=1;
int numreader=0;
int i;

void *writer(void *wno)
{
sem_wait(&wrt);
cnt=cnt*2;
printf("writer %d modified cnt:%d\n",(*((int*)wno)),cnt);
sem_post(&wrt);
}
void *reader(void *rno)
{
pthread_mutex_lock(&mutex);
numreader++;
if(numreader==1)
{
  sem_wait(&wrt);
}
pthread_mutex_unlock(&mutex);
printf("reader: %d read cnt:%d\n",*((int *)rno),cnt);
pthread_mutex_lock(&mutex);
numreader--;
if(numreader==0)
{
sem_post(&wrt);
}
pthread_mutex_unlock(&mutex);
}
int main()
{
pthread_t r[10],w[5];
pthread_mutex_init(&mutex,NULL);
sem_init(&wrt,0,1);
for(i=0;i<10;i++)
{
pthread_create(&r[i],NULL,(void *)reader,(void *)&i);
}
for( i=0;i<5;i++)
{
     pthread_create(&w[i],NULL,(void *)writer,(void *)&i);
}
for( i=0;i<10;i++)
{
pthread_join(r[i],NULL);
}
for( i=0;i<5;i++)
{
pthread_join(w[i],NULL);
}
pthread_mutex_destroy(&mutex);
sem_destroy(&wrt);
return 0;
}
--------------------------------------------------------------------------------------------------------------------------------------------------

